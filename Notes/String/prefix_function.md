# 前缀函数

## 前缀函数定义

给定长度为 `n` 的字符串 `s`，其前缀函数 `pi` 是一个长度为 `n` 的整型数组，定义为

1. 如果 `s[0...i]` 有一对相等的 (长度为 `k`) 真前缀与真后缀 `s[0...k]` 和 `s[i-k+1...i]`，则 `pi[i]` 是这个相等的真前缀长度，即 `pi[i] = k`
2. 如果有不止一对相等的真前缀和真后缀，则 `pi[i]` 是其中最长的一对的长度
3. 否则，`pi[i] = 0`

特别地，`pi[0] = 0` (因为 `s[0]` 没有真前缀和真后缀)

> `pi[i]` 是子串 `s[0...i]` 最长的相等的真前缀和真后缀的长度

例如，考虑字符串 `abcabcd`

|  `i`  | `substr`  | `pi`  |
| :---: | :-------: | :---: |
|   0   |    `a`    |   0   |
|   1   |   `ab`    |   0   |
|   2   |   `abc`   |   0   |
|   3   |  `abca`   |   1   |
|   4   |  `abcab`  |   2   |
|   5   | `abcabc`  |   3   |
|   6   | `abcabcd` |   0   |

## 前缀函数算法

### 朴素算法

1. 从 `i = 1` 遍历到 `i = n-1`，枚举所有子串
2. 对每个子串 (由 `i` 标记)，从最长的真前缀长度 (`j = i` 枚举到 `j = 0`) 开始尝试比较
3. 如果当前真前缀和真后缀相等，则此时长度为 `pi[i]`，否则 `j -= 1`

```cpp
vector<int> prefix_function_naive(string s) {
    int n = (int) s.length();
    vector<int> pi(n, 0);

    for (int i = 1; i < n; ++i) {
        for (int j = i; j >= 0; --j) {
            if (s.substr(0, j) == s.substr(i - j + 1, i + 1)) {
                pi[i] = j;
                break;
            }
        }
    }
}
```

该朴素算法的复杂度为 `O(n^3)`

### 优化-1

注意到，相邻的前缀函数值 **至多增加 1**。同时，在匹配 `pi[i+1]` 时，如果能匹配上，则新增的字符 `s[i+1]` (出现在新的真后缀最后一位) 应该与 `pi[i]` 标定的最长真前缀的下一个字符相等 (`s[i+1] = s[pi[i]]`)，此时新增字符才能和新的真前缀正确匹配，且有 `pi[i+1] = pi[i] + 1`。

|   a   |   b   |   c   |   a   |   b   |   c   |   d   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   0   |   0   |   0   |   1   |   2   |   3   |   0   |

- 例如， `i = 3` 时，新增的 `s[i] = s[3] = 'a'`，要求 `s[pi[i-1]] = pi[0] = 'a'` 和 `pi[3]` 相等
- 同理， `i = 4` 时，新增的 `s[i] = s[4] = 'b'`，要求 `s[pi[i-1]] = pi[1] = 'b'` 和 `pi[4]` 相等

基于这个观察，优化后的算法为

```cpp
vector<int> prefix_function_optimized(string s) {
    int n = (int) s.length();
    vector<int> pi(n, 0);

    for (int i = 0; i < n; ++i) {
        // change from j = i to j = pi[i - 1] + 1
        for (int j = pi[i - 1] + 1; j >= 0; --j) {
            if (s.substr(0, j) == s.substr(i - j + 1, i + 1)) {
                pi[i] = j;
                break;
            }
        }
    }
}
```

优化后算法复杂度为 `O(n^2)`

### 优化-2

在上一个优化中，最好的情况是 `s[i+1] == s[pi[i]]` 时，此时只需要一次字符串比较就可以得到结果，而在 `s[i+1] != s[pi[i]]` 时，则要递减回退。作为进一步优化，考虑 `s[i+1] != s[pi[i]]` 时的回退策略。

> 为了简洁起见，我们使用 `s[i: j]` 表示 `s` 的第 `i` 个字符到第 `j` 个字符组成的子串，该子串包括 `i` 和 `j` 两个端点。

我们希望在失配时，找到某个仅次于 `pi[i]` 的长度 `j`，使得 `s[0: j-1]` 和 `s[i-j+1: i]` (即 `s` 的前 `j` 个字符和后 `j` 个字符仍然相等)。

注意到，对于字符串 `s[0: i]`，`s[0: j-1]` 是它开头的 `j` 个字符，而 `s[i-j+1: i]` 是它结尾的 `j` 个字符。

同时，又因为 `s[0: pi[i]-1] == s[i-pi[i]+1: i]`，因此 `s[i-j+1: i]` 同时是 `s[0: pi[i]-1]` 的末尾 `j` 个字符

整理一下

- `s[0: j-1]` 和 `s[i-j+1: i]` 相等
- `s[0: j-1]` 和 `s[i-j+1: i]` 分别可以看做 `s[0: pi[i]-1]` 的前 `j` 个和后 `j` 个字符

换句话说，`s[0: pi[i]-1]` 的开头 `j` 个字符 (`s[0: j-1]`) 和结尾 `j` 个字符 (`s[pi[i] - j: pi[i]-1]`) 相等，故 `j` 是 `s[0: pi[i]-1]` 的前缀函数。

故 `j = pi[pi[i] - 1]`，或者更泛化地说，`j = pi[j - 1]`

|   0   |   1   |   2   |   3   |   4   |    5    |   6   |   7   |   8   |
| :---: | :---: | :---: | :---: | :---: | :-----: | :---: | :---: | :---: |
|   x   |   x   |   y   |   x   |   x   |    y    |   x   |   x   |   x   |
|   0   |   1   |   0   |   1   |   2   |    3    |   4   |   5   |   2   |
|       |       |       |       |       | `pi[i]` |       |  `i`  | `i+1` |

作为例子，考虑 `i` 为 7、`i+1` 为 8 时，匹配 `s[i+1] == pi[i]` 失败，需要回退，此时

- 已知 `s[0: pi[i]-1] = xxyxx` 和 `s[i-pi[i]+1: i] = xxyxx` 是匹配的
- 这里 `j = pi[pi[i] - 1] = pi[5-1] = 2`
- `s[i-j+1: i]` 是 `s[i-pi[i]+1: i]` (`xxyxx`) 的最后 `j` 个字符，它应该和 `s[0: pi[i]-1]` (`xxyxx`) 的最后 `j` 个字符，即 `s[pi[i]-j: pi[i]-1]` 也匹配
- 所以有 `s[0: j-1] = s[i-j+1: i] = s[pi[i]-j: pi[i]-1]`
- 也就是说，`s[0: pi[i]-1]` (`xxyxx`) 的前 `j` 个字符和后 `j` 个字符应该匹配
- 因此，`j` 事实上就是 `s[0: pi[i]-1]` 的前缀函数值
- `j = pi[pi[i] - 1] = 2`

因此，每次失配时，我们可以直接将 `j` 更新为 `pi[pi[i] - 1]`，从而实现更高效的回退

```cpp
vector<int> prefix_function_final(string s) {
    int n = (int) s.length();
    vector<int> pi(n, 0);

    for (int i = 1; i < n; ++i) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j])
            j = pi[j - 1];
        if (s[i] == s[j])
            j ++;
        pi[i] = j;
    }
}
```
